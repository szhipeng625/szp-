// 简单的博弈论，我们只需要关注Alice赢得情况，其余的情况就是Bob赢
// 我们只要Bob做出和Alice相同的动作，那么最后剩下的一定是相同的，反之Alice一定会有办法胜利
// 所以问题就转化为，Bob是否能和做出Alice相同的动作，Alice只有两种操作，所以只需要保证删除Bob存在的数字就一定会赢
// 最终推出，枚举每一次操作的数字，Bob如果不包含就Alice win

#include <bits/stdc++.h>

using namespace std;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    vector<int> b(n + 1);
    for(int i = 1; i <= n; i ++)    cin >> a[i];
    for(int i = 1; i <= n; i ++)    cin >> b[i];
    int t1 = 1, t2 = 1, t3 = n;
    while(t1 <= n){
        if(a[t1] == b[t2])
            t2 ++;
        else if(a[t1] == b[t3])
            t3 --;
        else{
            cout << "Alice\n";
            return ;
        }
        t1 ++;
    }
    t1 = n, t2 = n, t3 = 1;
    while(t1 >= 1){
        if(a[t1] == b[t2])
            t2 --;
        else if(a[t1] == b[t3])
            t3 ++;
        else{
            cout << "Alice\n";
            return ;
        }
        t1 --;
    }
    cout << "Bob\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin >> n;
    for(int i = 0; i < n; i ++)
        solve();
    return 0;
}
